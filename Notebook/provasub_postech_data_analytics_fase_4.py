# -*- coding: utf-8 -*-
"""ProvaSub - Postech - Data Analytics - Fase 4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DRHKQyvWjT_qkdDOKjghVBVXt-3QzHnU

# üõ¢Ô∏è Problema

Voc√™ foi escalado como cientista de dados em uma grande empresa de petr√≥leo e recebeu a miss√£o de criar um **modelo preditivo** para estimar o **pre√ßo do petr√≥leo em d√≥lar**. Esse modelo ser√° integrado a uma **aplica√ß√£o interativa** desenvolvida com Streamlit, com o objetivo de auxiliar gestores na **tomada de decis√µes estrat√©gicas** com base na varia√ß√£o do pre√ßo do petr√≥leo.

üìå **Base de dados principal**:  

[Pre√ßo do petr√≥leo bruto Brent (IPEADATA)](http://www.ipeadata.gov.br/ExibeSerie.aspx?module=m&serid=1650971490&oper=view)

**üì¶ Entreg√°veis**

- ‚úÖ Link da aplica√ß√£o com o modelo preditivo em Streamlit  
- ‚úÖ Notebook Python contendo toda a pipeline de constru√ß√£o do modelo  
- ‚úÖ Descri√ß√£o do objetivo e abordagem adotada


**üí° Proposta**

Durante o desenvolvimento, percebeu-se que utilizar **apenas a s√©rie hist√≥rica do pre√ßo do petr√≥leo** n√£o seria suficiente para gerar um modelo robusto. Para enriquecer a an√°lise, foram incorporados **dados complementares**, especialmente sobre a **produ√ß√£o mundial de petr√≥leo**.

Al√©m disso, estudos apontam que fatores **clim√°ticos** ‚Äî como o inverno em pa√≠ses do hemisf√©rio norte ‚Äî influenciam diretamente o consumo de petr√≥leo, o que pode provocar varia√ß√µes significativas no pre√ßo.

Com base nesses dados, o modelo buscar√° prever o valor m√©dio do barril de petr√≥leo considerando:

- Volume de produ√ß√£o mundial (m√©dia di√°ria de barris)  
- Esta√ß√£o do ano (como proxy para varia√ß√µes de consumo)  
- Tend√™ncias hist√≥ricas

O objetivo principal √© **identificar rela√ß√µes entre oferta (produ√ß√£o) e pre√ßo**, por exemplo:

- Quedas na produ√ß√£o podem causar aumento no pre√ßo?  
- Aumento na produ√ß√£o leva a redu√ß√£o de valor?

**üóÉÔ∏è Bases de Dados Utilizadas**

- üìà **Produ√ß√£o Mundial de Petr√≥leo**: [EIA - U.S. Energy Information Administration](https://www.eia.gov).

- üí∞ **Pre√ßo por Barril (Brent - FOB)**: [IPEADATA - C√≥digo EIA366_PBRENT366](http://www.ipeadata.gov.br).

# **Coleta de dados de produ√ß√£o de petr√≥leo**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import requests

from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import acf, pacf, adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA

# URL da API
url = "https://api.eia.gov/v2/international/data/?api_key=UdhM1dqnrlS4xz52WPEndusafc88YhT0bXXiWC51&frequency=monthly&data[0]=value&facets[activityId][]=1&facets[productId][]=53&facets[countryRegionId][]=WORL&facets[unit][]=TBPD&sort[0][column]=period&sort[0][direction]=desc&offset=0&length=5000"

# Requisi√ß√£o
res = requests.get(url)

# Garantir que a resposta tenha a codifica√ß√£o UTF-8
res.encoding = 'utf-8'

# Converter a resposta JSON para dicion√°rio
data = res.json()

# A parte dos dados est√° em data['response']['data']
base_producao = pd.DataFrame(data['response']['data'])

# Selecionando as colunas 'period' (data) e 'value' (valor)
base_producao = base_producao[['period', 'value']]

# Manter apenas ano e m√™s no formato 'YYYY-MM'
base_producao['period'] = pd.to_datetime(base_producao['period']).dt.to_period('M').astype(str)

# Opcional: definir 'period' como √≠ndice
base_producao.set_index('period', inplace=True)
base_producao.rename_axis('Data', inplace=True)

# Visualiza√ß√£o
base_producao.head()

"""# **Coleta de dados do valor do petr√≥leo**"""

import requests
import pandas as pd

# C√≥digo da s√©rie
codigo_serie = 'EIA366_PBRENT366'

# URL da API para obter os valores da s√©rie
url = f'http://www.ipeadata.gov.br/api/odata4/ValoresSerie(SERCODIGO=\'{codigo_serie}\')'

# Requisi√ß√£o GET para a API
response = requests.get(url)

# Verifique se a requisi√ß√£o foi bem-sucedida
if response.status_code == 200:
    # Converta a resposta JSON em um DataFrame
    data = response.json()
    base_valor = pd.DataFrame(data['value'])

    # Converter a coluna VALDATA para datetime (removendo fuso e mantendo apenas ano e m√™s)
    base_valor['VALDATA'] = pd.to_datetime(base_valor['VALDATA'], utc=True).dt.to_period('M').astype(str)
else:
    print(f'Erro ao acessar a API: {response.status_code}')

# Remover colunas desnecess√°rias
base_valor = base_valor.drop(columns=['SERCODIGO', 'NIVNOME', 'TERCODIGO'])

# Remover as datas duplicadas (mantendo a primeira ocorr√™ncia)
base_valor = base_valor.drop_duplicates(subset=['VALDATA'], keep='first')

# Definir a coluna VALDATA como √≠ndice e renome√°-la para "Ano-M√™s"
base_valor = base_valor.set_index('VALDATA').rename_axis('Data')

# Remover valores ausentes
base_valor = base_valor.dropna()

# Visualiza√ß√£o final
base_valor.head()

"""# **Juntando as duas bases em apenas um dataframe**"""

# Fazendo o merge pelas datas
df_unido = pd.merge(base_producao, base_valor, on='Data', how='inner')

print(df_unido.columns)

df_unido = df_unido.rename(columns={'value': 'Producao', 'VALVALOR': 'valor'})

df_unido.head()

"""# **Criando uma coluna com a esta√ß√£o do ano.**

Conforme perquisa a temperatura influencia diretamente no uso do petrol√©o pois em alguns paises o combustivel √© utilizado para aquecimento.
"""

# Fun√ß√£o para obter a esta√ß√£o do ano
def obter_estacao(data_str):
    mes = int(data_str.split('-')[1])
    if mes in [12, 1, 2]:
        return 'Ver√£o'
    elif mes in [3, 4, 5]:
        return 'Outono'
    elif mes in [6, 7, 8]:
        return 'Inverno'
    elif mes in [9, 10, 11]:
        return 'Primavera'

# Aplicar a fun√ß√£o ao √≠ndice e criar a nova coluna
df_unido['Estacao'] = df_unido.index.map(obter_estacao)

df_unido.head()

"""Visualiza√ß√£o dos valores e primeiros estudos para o desenvolvimento do Machine Leaning."""

import matplotlib.pyplot as plt

#Grafico de valor
df_unido['valor'].plot(figsize=(10, 6), linestyle='-', color='b')

#Adicionando r√≥tulos e Titulo ao grafico
plt.title('Varia√ß√£o do pre√ßo do Petr√≥leo')
plt.xlabel('Data')
plt.ylabel('Valor')

# Inverter a ordem dos anos (eixo X)
plt.gca().invert_xaxis()

#Exibindo o gr√°fico
plt.show()

#Transformando a coluna produ√ß√£o em numero
df_unido['Producao'] = pd.to_numeric(df_unido['Producao'], errors='coerce')

# Garantir que 'Producao' √© num√©rico
df_unido['Producao'] = pd.to_numeric(df_unido['Producao'], errors='coerce')

# Plot do gr√°fico
df_unido['Producao'].plot(figsize=(10, 6), linestyle='-', color='b')

# Adicionando r√≥tulos e t√≠tulo
plt.title('Varia√ß√£o da produ√ß√£o do Petr√≥leo')
plt.xlabel('Data')
plt.ylabel('Produ√ß√£o')

# Inverter a ordem dos anos (eixo X)
plt.gca().invert_xaxis()

# Exibir o gr√°fico
plt.show()

# Dados por ano e esta√ß√£o, calculando a m√©dia do valor
media_valor_por_estacao = df_unido.groupby([pd.to_datetime(df_unido.index).year, 'Estacao'])['valor'].mean().unstack()

# Gr√°fico de barras agrupadas
media_valor_por_estacao.plot(kind='bar', figsize=(10, 6))

# R√≥tulos e t√≠tulo ao gr√°fico
plt.title('Valor M√©dio do Petr√≥leo por Esta√ß√£o do Ano')
plt.xlabel('Ano')
plt.ylabel('Valor M√©dio')
plt.xticks(rotation=0)
plt.legend(title='Esta√ß√£o')

# Plotar
plt.tight_layout()
plt.show()

"""O gr√°fico apresenta a varia√ß√£o do valor m√©dio do petr√≥leo por esta√ß√£o do ano ao longo dos anos, de 1993 a 2025. Observa-se uma tend√™ncia geral de crescimento nos pre√ßos at√© por volta de 2008, com um pico expressivo nesse ano, seguido de uma queda brusca em 2009, o que pode estar associado √† crise financeira global. Ap√≥s esse per√≠odo, os valores retomam o crescimento, atingindo novo patamar elevado entre 2011 e 2014, seguido por outra queda acentuada. A partir de 2020, o gr√°fico mostra uma nova oscila√ß√£o significativa, provavelmente reflexo da pandemia de COVID-19 e instabilidades geopol√≠ticas. Em rela√ß√£o √†s esta√ß√µes do ano, os valores tendem a ser similares, com pequenas varia√ß√µes entre elas, sugerindo que a sazonalidade tem influ√™ncia limitada, embora o inverno e o outono frequentemente apresentem valores um pouco mais altos, possivelmente devido ao aumento da demanda por combust√≠veis para aquecimento em regi√µes temperadas.

# **Realizando a decomposi√ß√£o das serie temporal para um melhor entendimento em rela√ß√£o aos dados.**
"""

conteudo = seasonal_decompose(df_unido['valor'], model='multiplicative', period=5)

fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(15, 10))

conteudo.observed.plot(ax=ax1)  # S√©rie dos dados
conteudo.trend.plot(ax=ax2)     # Tend√™ncia dos dados
conteudo.seasonal.plot(ax=ax3)  # Sazonalidade
conteudo.resid.plot(ax=ax4)     # Res√≠duos

plt.tight_layout()

"""# **Criando o modelo de machine Leaning para realizar a previs√£o do pre√ßo dos combustiveis.**"""

!pip install ace_tools

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt
import numpy as np

df_unido.index = pd.to_datetime(df_unido.index)

# Filtrando os √∫ltimos 3 anos de dados
df_filtrado = df_unido[df_unido.index >= (df_unido.index.max() - pd.DateOffset(years=3))]

# Codificando a vari√°vel categ√≥rica "Estacao"
df_filtrado = pd.get_dummies(df_filtrado, columns=["Estacao"], drop_first=True)

# Separando features e target
X = df_filtrado.drop(columns=["valor"])
y = df_filtrado["valor"]

# Dividindo em treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Treinando o modelo
modelo = RandomForestRegressor(n_estimators=100, random_state=42)
modelo.fit(X_train, y_train)

# Fazendo previs√µes
y_pred = modelo.predict(X_test)

# Avaliando o modelo
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

# Exibindo comparativo entre valores reais e previstos
df_resultado = pd.DataFrame({'Real': y_test.values, 'Previsto': y_pred}, index=y_test.index)
print(df_resultado.head())

# Opcional: visualizar graficamente
df_resultado.plot(figsize=(12, 6), title='Valor Real vs Previsto')
plt.xlabel('Data')
plt.ylabel('Valor')
plt.grid(True)
plt.show()

r2, mae, rmse

"""# **Realizando previs√µes para os proximos 12 meses**"""

#Indice de datas mensais para os pr√≥ximos 12 meses
proximos_12_meses = pd.date_range(start=df_unido.index.max() + pd.DateOffset(months=1), periods=12, freq='MS')

# M√©dia da produ√ß√£o recente e esta√ß√£o por data
media_producao = df_filtrado['Producao'].mean()

def obter_estacao(mes):
    if mes in [12, 1, 2]:
        return 'Ver√£o'
    elif mes in [3, 4, 5]:
        return 'Outono'
    elif mes in [6, 7, 8]:
        return 'Inverno'
    else:
        return 'Primavera'

df_futuro = pd.DataFrame(index=proximos_12_meses)
df_futuro['Producao'] = media_producao  # ou outro valor estimado
df_futuro['Estacao'] = df_futuro.index.month.map(obter_estacao)

df_futuro = pd.get_dummies(df_futuro, columns=["Estacao"], drop_first=True)

# Garantir que todas as colunas est√£o presentes (igual ao treino)
for col in X_train.columns:
    if col not in df_futuro.columns:
        df_futuro[col] = 0

# Reordenar colunas
df_futuro = df_futuro[X_train.columns]

previsao_futura = modelo.predict(df_futuro)

# Resultado com datas
df_previsao = pd.DataFrame({'Data': df_futuro.index, 'Valor_Previsto': previsao_futura}).set_index('Data')
print(df_previsao)

# Plotar
df_previsao.plot(title='Previs√£o para os pr√≥ximos 12 meses', figsize=(12,6))
plt.xlabel('Data')
plt.ylabel('Valor Previsto')
plt.grid(True)
plt.show()

"""# **Extraindo o modelo:**"""

import joblib

# Salvar o modelo em um arquivo
joblib.dump(modelo, 'modelo_random_forest.pkl')

